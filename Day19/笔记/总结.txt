1.异常的体系
	Throwable
		Error:错误,一般是硬件问题, 我们不能解决
		Exception:
			编译时异常:
				特点: 编译期间就必须处理,否则编译通不过
				作用: 在编译期间起到一个提醒错误的作用, 让我们将异常扼杀在写代码的时候
				分类:除了运行时都是编译时异常
			运行时异常:
				特点: 运行时才会报错的异常, 编译期间可以不处理,也可以处理,如果不处理则交给jvm处理
				作用: 一般运行时异常是一些常识性的问题,不能犯的问题, 跟语法错误很类似
				分类:RuntimeException以及其子类都是运行时异常
2.jvm处理异常的方式
	将异常类型, 异常原因, 异常位置展示到控制台上, 将程序终止
3.异常的处理
	1.捕获异常:
		最终目的: 让程序不终止
		格式:
			try{
				可能出现问题的代码
				以及出现问题后不需要执行的代码
			}catch(异常类型 变量名){
			}catch(异常类型 变量名){
			}....
		执行流程:
			程序开始执行try里面的代码, 如果一旦发现异常就会造一个异常对象, 然后拿着异常对象
            和catch中的类型去匹配, 匹配成功则执行对应的catch里面语句,如果没有类型和
             异常对象匹配, 则处理异常失败, 还会交给jvm处理, 然后整个try catch结束;
            如果try里面没有异常出现, 则catch不会执行, catch就像备胎一样
		注意:
			1.try可以有很多个catch
            2.多个catch中异常的类型如果有继承关系, 我们应该将父类异常类型放到下面
			3.子类在重写父类有异常的方法时,不能比父类的方法抛出"更大"的异常
				Exception >  RuntimeException
			
	2.延时处理异常:
		通过throws关键字将异常类型声明出去,可以声明多个, 多个之间用","隔开
4.finally的使用(明天还会用到!!!这个可以放一放)
	注意: 不能单独使用
	格式:
		try{
		}finally{
		}
		
		try{
		}catch(异常类型 变量名){
		}....
		finally{
		}
	作用: 除非虚拟机停止,可以保证代码一定会执行,哪怕方法return 也会执行;
	使用场景: 用于释放资源的动作放到finally代码块, 保证我们的资源一定会释放,节省内存开销
5.throw关键字(理解!!!!!)
	throw和throws的区别
	throw:
		位置: 在方法内部可以出现
		作用: 用来制造异常对象,后面只能跟一个异常对象
		使用场景: 经常用于校验参数合法性, 如果参数不合法可以造异常给调用者
		开发过程中用的比较少, 除非做一些框架, 或者底层代码,希望给别人使用的时候才会这样做
		
	throws	
		位置: 在方法声明上
		作用: 用来声明异常的, 后面跟的是异常类名, 可以跟多个,多个之间用,隔开
		
6.自定义异常(理解!!!!!)
	异常唯一的区别就是类名不一样, 自定义异常说白了就是起一个好听的名字
	步骤:
		1.定义一个类继承Exception或者RuntimeException
		2.重写构造,提供有参构造, 给父类的成员变量赋值
		3.使用
7.File类 
	包:java.io
			
	构造:
		File(String pathname) (掌握!!!!!!!!!!!!)
			
		File(File parent, String child) 
			只有已知父目录的File表现形式找其子文件的时候才会这个构造,
            其他地方用不到
		File(String parent, String child) 
			只有已知父目录的字符串表现形式找其子文件的时候才会这个构造,
            其他地方用不到
	方法:
		跟创建有关的方法
			1.创建文件
				boolean createNewFile(); 创建文件并且返回是否创建成功 
					注意:
				    1.如果文件已经存在, 则不会创建成功
				    2.createNewFile只能创建文件不能创建夹,如果关联的文件所
				    在的文件夹不存在的话,会创建失败,而且报异常"系统找不到指定的路径"
				    3.不要以后缀名去判断文件或者文件夹,后缀名的作用是让指定的软件能够快速打开指定的文件
			2.创建文件夹
				boolean mkdir()  ; 创建单级目录
					注意: 只能创建单级目录
				boolean mkdirs()  ; 创建多级目录
					
		跟判断有关的方法
			boolean exists()  ;判断关联的文件或者文件夹是否存在
			boolean isDirectory()  ; 判断我们关联的是否是文件夹
			boolean isFile()  ; 判断我们关联是否是文件
			注意:如果关联的路径不存在的话isDirectory和isFile都返回false
		跟获取有关的方法
			long length()  ; 获取文件的内容大小, 返回字节个数
			String getName()  ;获取关联的文件或者文件夹的名字
			String getAbsolutePath() ;获取关联的绝对路径
		跟删除相关的方法
			boolean delete() ; 删除文件和文件夹
			1.删除的动作不走回收站,要小心
			2.如果文件夹的话, 除非里面没有内容才能删除,否则删除不了
 
		高级功能
			File[] listFiles()  ;---->获取一个文件夹中所有的一级子文件和文件夹, 将一级子文件和文件夹
					装到一个File数组返回;
			注意: 
				 1.这个是只有文件夹才可以使用的方法
			     2.只能获取一级子目录		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
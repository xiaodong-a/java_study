修饰符：
    * 权限修饰符：private，默认的，protected，public
    * 状态修饰符：static，final
    * 抽象修饰符：abstract
类：
    * 权限修饰符：默认修饰符，public
    * 状态修饰符：final（最终类不能被继承）
    * 抽象修饰符：abstract
    
成员变量：
    * 权限修饰符：private，默认的，protected，public
    * 状态修饰符：static，final
    
构造方法：
    * 权限修饰符：private，默认的，protected，public
    *私有构造方法的情况：当一个类中所有的方法都是静态的，就可以把构造方法私有


成员方法：
    * 权限修饰符：private，默认的，protected，public
    * 状态修饰符：static，final
    * 抽象修饰符：abstract
    
除此以外的组合规则：
    * 成员变量：public static final
    * 成员方法：
        * public static 
        * public abstract
        * public final
————————————————
版权声明：本文为CSDN博主「点墨漫雪」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/dianmomanxue/java/article/details/81294284
1.多态
	面向对象的第三大特征
	前提:
		必须有继承或者实现关系
		需要有方法重写(没有方法重写多态就失去了意义, 干脆使用父类就行了)
		需要有父类引用指向子类对象
	格式:
		父类类型 变量名 = new 子类类型();
2. 多态的好处
	提高方法的扩展性, 可以将父类或者父接口作为参数列表, 这样方法
	可以接受所有的子类或者实现类对象
3. 多态的弊端
	不能再使用子类特有的内容
	如何非要使用子类特有内容:
		可以向下转型
			格式: 子类类型 变量名 = (子类类型)父类引用;
			注意:
				向下转型必须是一个还原操作,否则出现ClassCastExcepotion(类型转换错误
)				为了解决向下转型的问题, java提供了一个关键字instanceof, 可以判断
				某个对象是否属于某一个类
				格式:
					对象 instanceof 类型 返回一个boolean类型的值
				例如:
					if(a instanceof Dog){
					}
4.多态之间的成员变量和成员方法的关系
	1.成员变量重复了(了解) ---->  直接访问, 我们得到是父类的结果,
		但是开发过程中, 一般情况咱们不能直接访问, 因为所有的成员变量都
		私有化了, 我们必须通过setter和getter"方法"来访问
	2.成员方法重复了 ---->
		调用的子类的方法!!!!, 外表可以模仿, 但是功能模仿不了
5.内部类
	概念: 定义在类中的类我们称为内部类
	成员内部类:
		位置: 类中方法外
		好处: 可以直接使用外部类的东西,甚至私有的,某些情况可以节省传参的问题
		格式:
			public class Outer{
				public class Inner{
				}
			}
		使用:
			外部类.内部类 变量名 = new 外部类().new 内部类();
			原因:
				内部类可以使用外部类的成员变量, 如果外部类的构造函数没有走, 内部类是不可以使用的
				内部类想要初始化, 一定要保证外部类的构造函数执行
		可以修饰成员内部类的修饰符:
			public, static, final, abstract, private
			private: 只能在本类中使用
			static: 静态的不能再使用外部类的非静态的东西,但是这个写法不推荐,
					不推荐的原因是, 内部类的好处是直接可以使用外部类的东西,
					 如果这样写, 将外部类的非私有的东西都摒弃了
	局部内部类:
		位置: 将类在方法内
		特点: 死都用不到,原因是因为范围小了, 没必要定义!!!!!
	匿名内部类:
		格式:
			new 已知类|已知接口(){
				对方法进行重写
			
			}
		作用: 可以快速的创建一个已知类或者已知接口的子类或者实现类对象
		使用场景: 快速的创建一个已知类或者已知接口的子类或者实现类对象,不用再额外定义类了
		注意: 仅限于咱们子类比较简单的时候,建议使用, 如果子类很复杂,不建议使用,因为阅读不方便
		
6.权限修饰符
	public: 哪里都可以
	protected: 本包下, 以及不同包的子类
	空的: 本包下
	private: 本类中
	总结:
		开发过程中,一般使用public 和private就能满足你所有的需求了!!!!!!
	导包的秘密:
		如果要使用的类和本类在同一个文件夹, 或者要使用的类在java.lang包下的可以省略导包
		其他情况必须导入包才能使用
7.代码块
	1.局部代码块(不常用,没什么卵用!!!!)
		位置:
			在方法中
		格式:
			{
			}
		作用:
			区分多个局部,解决局部变量冲突的问题,让限制变量的生命周期
	2.构造代码块(没什么卵用!!!!)
		位置:
			类中方法外
		格式:
			{}
		作用: 抽取多个构造中的共性内容
		特点:
			只要走了构造函数, 我们的构造代码块会先执行
		总结:
			这个一般情况不用, 不用的原因是因为有缺陷, 如果有成员变量初始化,
			构造代码块先于构造执行
	3.静态代码块(掌握)
		位置:
			类中方法外
		格式:
			static{}
		作用: 随着类的加载而加载, 只会执行一次
		特点: 只会执行一次
		使用场景:
			用来加载一次性的配置文件,或者驱动jar包用的
	4.同步代码块(线程的时候会讲解)
		
		
		
测试接口中A,B如果有相同的静态方法，会怎么样.

实现类中的静态方法
A中的静态方法
B中的静态方法

Process finished with exit code 0


三个静态方法不冲突
============================
接口中静态方法、默认方法、抽象方法相同怎么办
一个接口中有默认方法(抽象)和静态(抽象)方法相同，会冲突。即使静态方法属于接口，默认方法属于实现类的实例。

如果是两个接口呢？
首先方法以类优先，然后找接口
A和B中有相同的静态方法，不会冲突，可以推测，A静态和B的默认抽象静态不冲突，不考虑静态方法
A:抽象 B:抽象  实现类不能是static  也得是非静态才能覆盖
A:抽象 B:默认  实现类还是得覆盖才行
A:默认 B:默认  重写
=====================================
类方法中能不能传入自己的类实例参数
FU(FU)
可以。

子类中能否重写父类的私有变量
主要看set get 方法的就近原则

多态时，方法是可以被重写调用子类的,但属性还是自己的
Fu fu = New Zi();
注意规范，最好不要父类变量重名，不然麻烦
=============================================
类方法中能不能传入自己的类实例参数
可以。

子类中能否重写父类的私有变量
主要看set get 方法的就近原则

多态时，方法是可以被重写调用子类的,但属性还是自己的
Fu fu = New Zi();
注意规范，最好不要父类变量重名，不然麻烦
==============================================
不允许static修饰方法变量  main方法也不行
静态内部类不能访问外部类非静态变量